package task

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// ---- textProgressBar --------------------------------------------------------

func TestTextProgressBar_Zero(t *testing.T) {
	t.Parallel()

	bar := textProgressBar(0, 16)
	assert.Equal(t, strings.Repeat("░", 16), bar, "0%% bar must be all empty")
	assert.Len(t, []rune(bar), 16)
}

func TestTextProgressBar_Full(t *testing.T) {
	t.Parallel()

	bar := textProgressBar(100, 16)
	assert.Equal(t, strings.Repeat("█", 16), bar, "100%% bar must be all filled")
	assert.Len(t, []rune(bar), 16)
}

func TestTextProgressBar_Half(t *testing.T) {
	t.Parallel()

	bar := textProgressBar(50, 16)
	assert.Equal(t, strings.Repeat("█", 8)+strings.Repeat("░", 8), bar)
	assert.Len(t, []rune(bar), 16)
}

func TestTextProgressBar_60Percent(t *testing.T) {
	t.Parallel()

	// 60% of 16 = 9.6 -> floor 9 filled, 7 empty
	bar := textProgressBar(60, 16)
	assert.Equal(t, strings.Repeat("█", 9)+strings.Repeat("░", 7), bar)
}

func TestTextProgressBar_TableDriven(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name      string
		percent   int
		width     int
		wantFill  int
		wantEmpty int
	}{
		{"0%% width 16", 0, 16, 0, 16},
		{"100%% width 16", 100, 16, 16, 0},
		{"50%% width 16", 50, 16, 8, 8},
		{"25%% width 16", 25, 16, 4, 12},
		{"75%% width 16", 75, 16, 12, 4},
		{"0%% width 8", 0, 8, 0, 8},
		{"100%% width 8", 100, 8, 8, 0},
		{"33%% width 9", 33, 9, 2, 7},
		{"clamps below 0", -5, 16, 0, 16},
		{"clamps above 100", 105, 16, 16, 0},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			bar := textProgressBar(tt.percent, tt.width)
			filled := strings.Count(bar, "█")
			empty := strings.Count(bar, "░")
			assert.Equal(t, tt.wantFill, filled, "filled count")
			assert.Equal(t, tt.wantEmpty, empty, "empty count")
			assert.Equal(t, tt.width, len([]rune(bar)), "total bar width")
		})
	}
}

// ---- escapePipeChars --------------------------------------------------------

func TestEscapePipeChars(t *testing.T) {
	t.Parallel()

	tests := []struct {
		input string
		want  string
	}{
		{"no pipes", "no pipes"},
		{"a|b", `a\|b`},
		{"a|b|c", `a\|b\|c`},
		{"|leading", `\|leading`},
		{"trailing|", `trailing\|`},
		{"", ""},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.input, func(t *testing.T) {
			t.Parallel()
			assert.Equal(t, tt.want, escapePipeChars(tt.input))
		})
	}
}

// ---- NewProgressGenerator ---------------------------------------------------

func TestNewProgressGenerator_NilSpecs(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)
	require.NotNil(t, pg)
	assert.Empty(t, pg.specMap)
}

func TestNewProgressGenerator_BuildsSpecMap(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(specs, sm, []Phase{})
	require.NoError(t, err)
	require.NotNil(t, pg)
	assert.Len(t, pg.specMap, 2)
	assert.Contains(t, pg.specMap, "T-001")
	assert.Contains(t, pg.specMap, "T-002")
}

// ---- Generate / WriteTo -----------------------------------------------------

func TestGenerate_ContainsProjectName(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	out, err := pg.Generate("MyProject")
	require.NoError(t, err)

	assert.Contains(t, out, "MyProject")
	assert.Contains(t, out, "Auto-generated by Raven")
}

func TestGenerate_AutoGeneratedHeader(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	out, err := pg.Generate("Raven")
	require.NoError(t, err)

	assert.Contains(t, out, "# Progress -- Raven")
	assert.Contains(t, out, "Auto-generated by Raven")
	assert.Contains(t, out, "Last updated:")
}

func TestGenerate_OverallProgressSummary(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-002"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	// 1 of 2 tasks completed = 50%
	assert.Contains(t, out, "1/2 tasks completed (50%)")
}

func TestGenerate_OverallProgress_AllComplete(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-002"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
		"T-002|completed|codex||",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "2/2 tasks completed (100%)")
}

func TestGenerate_OverallProgress_NoneComplete(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-002"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "0/2 tasks completed (0%)")
}

func TestGenerate_NoTasks_ZeroProgress(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	out, err := pg.Generate("EmptyProject")
	require.NoError(t, err)

	assert.Contains(t, out, "0/0 tasks completed (0%)")
}

func TestGenerate_PhaseSection(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Foundation", StartTask: "T-001", EndTask: "T-002"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "## Phase 1: Foundation")
	assert.Contains(t, out, "50%")
	assert.Contains(t, out, "1/2")
}

func TestGenerate_TaskRow_CompletedShowsAgent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Setup Project", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude|2024-01-15T10:00:00Z|",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "T-001")
	assert.Contains(t, out, "Setup Project")
	assert.Contains(t, out, "completed")
	assert.Contains(t, out, "claude")
	assert.Contains(t, out, "2024-01-15")
}

func TestGenerate_TaskRow_InProgressShowsAgent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Some Task", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{
		"T-001|in_progress|codex|2024-03-01T08:00:00Z|",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "in_progress")
	assert.Contains(t, out, "codex")
}

func TestGenerate_TaskRow_NotStartedEmptyAgent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Some Task", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "not_started")
	// The agent column for a not_started task should be empty
	// We check the row format: | T-001 | Some Task | not_started |  |  |
	assert.Contains(t, out, "| T-001 |")
}

func TestGenerate_TaskRow_BlockedEmptyAgent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Blocked Task", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{
		"T-001|blocked|some-agent||",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "blocked")
	// Blocked tasks should have empty agent field, not "some-agent"
	assert.NotContains(t, out, "some-agent")
}

func TestGenerate_TasksOrderedByID(t *testing.T) {
	t.Parallel()

	// Specs provided in reverse order; output must be in numeric ID order.
	specs := []*ParsedTaskSpec{
		makeSpec("T-003", nil),
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-003"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	posT001 := strings.Index(out, "T-001")
	posT002 := strings.Index(out, "T-002")
	posT003 := strings.Index(out, "T-003")
	assert.Greater(t, posT002, posT001, "T-002 must appear after T-001")
	assert.Greater(t, posT003, posT002, "T-003 must appear after T-002")
}

func TestGenerate_MultiplePhases(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
		makeSpec("T-003", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Foundation", StartTask: "T-001", EndTask: "T-002"},
		{ID: 2, Name: "Implementation", StartTask: "T-003", EndTask: "T-003"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
		"T-002|completed|claude||",
		"T-003|in_progress|codex||",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("MultiPhase")
	require.NoError(t, err)

	assert.Contains(t, out, "## Phase 1: Foundation")
	assert.Contains(t, out, "## Phase 2: Implementation")
	// Overall: 2 of 3 completed = 66%
	assert.Contains(t, out, "2/3 tasks completed (66%)")
}

func TestGenerate_ProgressBar_0Percent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{makeSpec("T-001", nil)}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, strings.Repeat("░", 16))
}

func TestGenerate_ProgressBar_100Percent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{makeSpec("T-001", nil)}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{"T-001|completed|claude||"})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, strings.Repeat("█", 16))
}

func TestGenerate_TitlePipeEscaped(t *testing.T) {
	t.Parallel()

	spec := &ParsedTaskSpec{
		ID:           "T-001",
		Title:        "Title with | pipe char",
		Dependencies: []string{},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator([]*ParsedTaskSpec{spec}, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, `Title with \| pipe char`)
}

func TestGenerate_OrphanStateIgnored(t *testing.T) {
	t.Parallel()

	// State file has T-099 which has no corresponding spec -- must be ignored.
	specs := []*ParsedTaskSpec{makeSpec("T-001", nil)}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
		"T-099|completed|claude||", // orphaned
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.NotContains(t, out, "T-099")
}

func TestGenerate_SpecWithNoStateIsNotStarted(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{makeSpec("T-001", nil)}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "T-001")
	assert.Contains(t, out, "not_started")
}

func TestGenerate_PhaseWithNoSpecsInRange(t *testing.T) {
	t.Parallel()

	// Phase range T-050 to T-051 but no specs in that range.
	phases := []Phase{
		{ID: 5, Name: "Empty Phase", StartTask: "T-050", EndTask: "T-051"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	assert.Contains(t, out, "## Phase 5: Empty Phase")
	assert.Contains(t, out, "0/2")
}

func TestGenerate_TimestampFormat(t *testing.T) {
	t.Parallel()

	spec := &ParsedTaskSpec{ID: "T-001", Title: "Task One", Dependencies: []string{}}
	phases := []Phase{{ID: 1, Name: "P1", StartTask: "T-001", EndTask: "T-001"}}

	// Write state with a known timestamp.
	ts := time.Date(2024, 6, 15, 12, 0, 0, 0, time.UTC)
	dir := t.TempDir()
	path := filepath.Join(dir, "task-state.conf")
	line := "T-001|completed|claude|" + ts.Format(time.RFC3339) + "|\n"
	require.NoError(t, os.WriteFile(path, []byte(line), 0644))
	sm := NewStateManager(path)

	pg, err := NewProgressGenerator([]*ParsedTaskSpec{spec}, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	// Date should appear in YYYY-MM-DD format.
	assert.Contains(t, out, "2024-06-15")
}

func TestGenerate_ZeroTimestampIsEmpty(t *testing.T) {
	t.Parallel()

	spec := &ParsedTaskSpec{ID: "T-001", Title: "Task One", Dependencies: []string{}}
	phases := []Phase{{ID: 1, Name: "P1", StartTask: "T-001", EndTask: "T-001"}}

	// State entry with empty timestamp field.
	sm := writeStateContent(t, []string{"T-001|completed|claude||"})
	pg, err := NewProgressGenerator([]*ParsedTaskSpec{spec}, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("TestProject")
	require.NoError(t, err)

	// No date placeholder should appear
	assert.NotContains(t, out, "0001-01-01")
}

// ---- WriteTo ----------------------------------------------------------------

func TestWriteTo_WritesToWriter(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	var buf strings.Builder
	err = pg.WriteTo(&buf, "WriterTest")
	require.NoError(t, err)

	assert.Contains(t, buf.String(), "WriterTest")
}

// ---- WriteFile --------------------------------------------------------------

func TestWriteFile_CreatesFile(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	dir := t.TempDir()
	path := filepath.Join(dir, "PROGRESS.md")

	require.NoError(t, pg.WriteFile(path, "FileTest"))

	content, err := os.ReadFile(path)
	require.NoError(t, err)
	assert.Contains(t, string(content), "FileTest")
}

func TestWriteFile_AtomicWrite_NoTmpFileLeft(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	dir := t.TempDir()
	path := filepath.Join(dir, "PROGRESS.md")

	require.NoError(t, pg.WriteFile(path, "AtomicTest"))

	// The .tmp file must not exist after a successful write.
	_, err = os.Stat(path + ".tmp")
	assert.True(t, os.IsNotExist(err), "temp file must be cleaned up after rename")
}

func TestWriteFile_CreatesParentDirectories(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	dir := t.TempDir()
	path := filepath.Join(dir, "nested", "deep", "PROGRESS.md")

	require.NoError(t, pg.WriteFile(path, "NestedTest"))

	_, err = os.Stat(path)
	assert.NoError(t, err, "file should exist at nested path")
}

func TestWriteFile_ContentMatchesGenerate(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{makeSpec("T-001", nil)}
	phases := []Phase{{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"}}
	sm := writeStateContent(t, []string{"T-001|completed|claude||"})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	dir := t.TempDir()
	path := filepath.Join(dir, "PROGRESS.md")

	require.NoError(t, pg.WriteFile(path, "ContentTest"))

	content, err := os.ReadFile(path)
	require.NoError(t, err)

	// Must contain the expected markdown elements.
	s := string(content)
	assert.Contains(t, s, "# Progress -- ContentTest")
	assert.Contains(t, s, "## Phase 1: Phase One")
	assert.Contains(t, s, "T-001")
	assert.Contains(t, s, "completed")
	assert.Contains(t, s, "claude")
}

// ---- buildProgressData integration -----------------------------------------

func TestBuildProgressData_MultiPhaseOverall(t *testing.T) {
	t.Parallel()

	// Phase 1: T-001 (completed), T-002 (not_started)
	// Phase 2: T-003 (completed)
	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
		makeSpec("T-003", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-002"},
		{ID: 2, Name: "Phase Two", StartTask: "T-003", EndTask: "T-003"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
		"T-003|completed|codex||",
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	data, err := pg.buildProgressData("MultiPhaseTest")
	require.NoError(t, err)

	assert.Equal(t, "MultiPhaseTest", data.ProjectName)
	assert.Equal(t, 3, data.OverallTotal)
	assert.Equal(t, 2, data.OverallComplete)
	assert.Equal(t, 66, data.OverallPercent) // floor(2/3*100)
	assert.Len(t, data.Phases, 2)
}

func TestBuildProgressData_PhaseCounts(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
		makeSpec("T-003", nil),
		makeSpec("T-004", nil),
		makeSpec("T-005", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-005"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
		"T-002|in_progress|codex||",
		"T-003|blocked|||",
		"T-004|skipped|||",
		// T-005 -> not_started
	})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	data, err := pg.buildProgressData("CountTest")
	require.NoError(t, err)

	require.Len(t, data.Phases, 1)
	pd := data.Phases[0]
	assert.Equal(t, 1, pd.Completed)
	assert.Equal(t, 1, pd.InProgress)
	assert.Equal(t, 1, pd.Blocked)
	assert.Equal(t, 1, pd.Skipped)
	assert.Equal(t, 1, pd.NotStarted)
	assert.Equal(t, 5, pd.Total)
	assert.Equal(t, 20, pd.Percent) // 1 of 5 = 20%
}

// ---- Table-driven: Generate output format -----------------------------------

func TestGenerate_TableDriven(t *testing.T) {
	t.Parallel()

	phases := []Phase{
		{ID: 1, Name: "TestPhase", StartTask: "T-001", EndTask: "T-003"},
	}

	tests := []struct {
		name        string
		specs       []*ParsedTaskSpec
		stateLines  []string
		wantContain []string
		wantAbsent  []string
	}{
		{
			name:  "empty specs",
			specs: nil,
			wantContain: []string{
				"# Progress",
				"Auto-generated by Raven",
				// Phase has range T-001..T-003 = 3 task IDs; unmanaged tasks count as not_started
				"0/3 tasks completed (0%)",
			},
		},
		{
			name:  "single task not started",
			specs: []*ParsedTaskSpec{makeSpec("T-001", nil)},
			wantContain: []string{
				"T-001",
				"not_started",
				"0/",
			},
		},
		{
			name:  "single task completed",
			specs: []*ParsedTaskSpec{makeSpec("T-001", nil)},
			stateLines: []string{
				"T-001|completed|claude||",
			},
			wantContain: []string{
				"T-001",
				"completed",
				"claude",
				"1/",
			},
		},
		{
			name: "all statuses",
			specs: []*ParsedTaskSpec{
				makeSpec("T-001", nil),
				makeSpec("T-002", nil),
				makeSpec("T-003", nil),
			},
			stateLines: []string{
				"T-001|completed|claude||",
				"T-002|in_progress|codex||",
				"T-003|blocked|||",
			},
			wantContain: []string{
				"completed",
				"in_progress",
				"blocked",
			},
		},
		{
			name: "skipped task",
			specs: []*ParsedTaskSpec{
				makeSpec("T-001", nil),
				makeSpec("T-002", nil),
			},
			stateLines: []string{
				"T-001|completed|claude||",
				"T-002|skipped|||",
			},
			wantContain: []string{"skipped", "completed"},
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			var sm *StateManager
			if len(tt.stateLines) > 0 {
				sm = writeStateContent(t, tt.stateLines)
			} else {
				sm = emptyStateManager(t)
			}

			pg, err := NewProgressGenerator(tt.specs, sm, phases)
			require.NoError(t, err)

			out, err := pg.Generate("TableTest")
			require.NoError(t, err)

			for _, want := range tt.wantContain {
				assert.Contains(t, out, want, "expected %q in output", want)
			}
			for _, absent := range tt.wantAbsent {
				assert.NotContains(t, out, absent, "expected %q NOT in output", absent)
			}
		})
	}
}

// ---- textProgressBar: acceptance-criteria cases (33%, edge cases) -----------

// TestTextProgressBar_33Percent is the explicit acceptance-criteria test:
// textProgressBar(33, 16) must return approximately one-third filled.
// floor(33*16/100) = floor(5.28) = 5 filled, 11 empty.
func TestTextProgressBar_33Percent(t *testing.T) {
	t.Parallel()

	bar := textProgressBar(33, 16)
	filled := strings.Count(bar, "█")
	empty := strings.Count(bar, "░")

	assert.Equal(t, 5, filled, "33%% of 16 should yield 5 filled chars (floor)")
	assert.Equal(t, 11, empty, "33%% of 16 should yield 11 empty chars")
	assert.Equal(t, 16, len([]rune(bar)), "bar must be exactly 16 runes wide")
}

// TestTextProgressBar_ZeroWidth verifies width=0 produces an empty string.
func TestTextProgressBar_ZeroWidth(t *testing.T) {
	t.Parallel()

	bar := textProgressBar(50, 0)
	assert.Equal(t, "", bar, "zero-width bar must be empty string")
}

// TestTextProgressBar_OneWidth exercises the width=1 boundary condition.
func TestTextProgressBar_OneWidth(t *testing.T) {
	t.Parallel()

	tests := []struct {
		percent   int
		wantFill  int
		wantEmpty int
	}{
		{0, 0, 1},
		{50, 0, 1},  // floor(50*1/100) = 0 filled
		{100, 1, 0},
	}
	for _, tt := range tests {
		tt := tt
		t.Run(fmt.Sprintf("%d%%_width1", tt.percent), func(t *testing.T) {
			t.Parallel()
			bar := textProgressBar(tt.percent, 1)
			assert.Equal(t, tt.wantFill, strings.Count(bar, "█"), "filled count")
			assert.Equal(t, tt.wantEmpty, strings.Count(bar, "░"), "empty count")
		})
	}
}

// TestTextProgressBar_CharacterEncoding verifies the Unicode block element
// characters (U+2588 FULL BLOCK and U+2591 LIGHT SHADE) are used.
func TestTextProgressBar_CharacterEncoding(t *testing.T) {
	t.Parallel()

	bar := textProgressBar(50, 2)
	runes := []rune(bar)
	require.Len(t, runes, 2)
	assert.Equal(t, '█', runes[0], "filled char must be U+2588 FULL BLOCK")
	assert.Equal(t, '░', runes[1], "empty char must be U+2591 LIGHT SHADE")
}

// ---- escapePipeChars: additional edge case -----------------------------------

// TestEscapePipeChars_NoRawPipe verifies that strings without any pipe chars
// are returned unchanged.
func TestEscapePipeChars_NoRawPipe(t *testing.T) {
	t.Parallel()

	input := `no pipes here` // no pipe characters at all
	assert.Equal(t, input, escapePipeChars(input),
		"string without pipe must be returned unchanged")
}

// ---- WriteTo: error path -----------------------------------------------------

// failWriter is an io.Writer that always returns an error.
type failWriter struct{}

func (f *failWriter) Write(_ []byte) (int, error) {
	return 0, fmt.Errorf("simulated write failure")
}

// TestWriteTo_FailingWriter_ReturnsError verifies that WriteTo propagates write
// errors from the underlying writer.
func TestWriteTo_FailingWriter_ReturnsError(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	err = pg.WriteTo(&failWriter{}, "FailTest")
	assert.Error(t, err, "WriteTo must return an error when the writer fails")
}

// TestWriteTo_WritesToIOWriter verifies WriteTo accepts any io.Writer (not just
// *bytes.Buffer), satisfying the function signature contract.
func TestWriteTo_WritesToIOWriter(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	require.NoError(t, pg.WriteTo(io.Discard, "DiscardTest"))
}

// TestWriteTo_BytesBuffer verifies WriteTo produces output equivalent to
// Generate by writing into a bytes.Buffer and checking expected content.
func TestWriteTo_BytesBuffer(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{makeSpec("T-001", nil)}
	phases := []Phase{{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"}}
	sm := writeStateContent(t, []string{"T-001|completed|claude||"})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	var buf bytes.Buffer
	require.NoError(t, pg.WriteTo(&buf, "BufProject"))

	out := buf.String()
	assert.Contains(t, out, "# Progress -- BufProject")
	assert.Contains(t, out, "T-001")
	assert.Contains(t, out, "completed")
	assert.Contains(t, out, "claude")
}

// ---- WriteFile: additional coverage -----------------------------------------

// TestWriteFile_InvalidPath_ReturnsError verifies that WriteFile returns an
// error when a path component is a regular file (not a directory).
func TestWriteFile_InvalidPath_ReturnsError(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	dir := t.TempDir()
	// Create a regular file that will block directory creation beneath it.
	blockFile := filepath.Join(dir, "not-a-dir")
	require.NoError(t, os.WriteFile(blockFile, []byte("x"), 0644))

	badPath := filepath.Join(blockFile, "PROGRESS.md")
	err = pg.WriteFile(badPath, "ErrorTest")
	assert.Error(t, err, "WriteFile must fail when a path component is a regular file")
}

// TestWriteFile_OverwritesExistingFile verifies that a second WriteFile call
// replaces the first atomically, with no residual content from the first run.
func TestWriteFile_OverwritesExistingFile(t *testing.T) {
	t.Parallel()

	dir := t.TempDir()
	path := filepath.Join(dir, "PROGRESS.md")

	sm1 := emptyStateManager(t)
	pg1, err := NewProgressGenerator(nil, sm1, []Phase{})
	require.NoError(t, err)
	require.NoError(t, pg1.WriteFile(path, "First"))

	sm2 := emptyStateManager(t)
	pg2, err := NewProgressGenerator(nil, sm2, []Phase{})
	require.NoError(t, err)
	require.NoError(t, pg2.WriteFile(path, "Second"))

	content, err := os.ReadFile(path)
	require.NoError(t, err)
	assert.Contains(t, string(content), "Second")
	assert.NotContains(t, string(content), "First")
}

// TestWriteFile_TmpFileNotLeft_DirListing checks that no *.tmp files survive
// by listing the directory after a successful WriteFile.
func TestWriteFile_TmpFileNotLeft_DirListing(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	dir := t.TempDir()
	path := filepath.Join(dir, "PROGRESS.md")
	require.NoError(t, pg.WriteFile(path, "CleanupTest"))

	entries, err := os.ReadDir(dir)
	require.NoError(t, err)
	for _, e := range entries {
		assert.False(t, strings.HasSuffix(e.Name(), ".tmp"),
			"no .tmp files should remain after successful WriteFile: found %s", e.Name())
	}
}

// ---- Generate: two phases with mixed statuses (acceptance criterion) ---------

// TestGenerate_TwoPhases_MixedStatuses is the explicit acceptance-criteria test
// for "Generate with 2 phases, mixed statuses: correct markdown output."
func TestGenerate_TwoPhases_MixedStatuses(t *testing.T) {
	t.Parallel()

	// Phase 1: T-001 (completed), T-002 (in_progress)
	// Phase 2: T-003 (not_started), T-004 (blocked)
	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Alpha Task", Dependencies: []string{}},
		{ID: "T-002", Title: "Beta Task", Dependencies: []string{}},
		{ID: "T-003", Title: "Gamma Task", Dependencies: []string{"T-001"}},
		{ID: "T-004", Title: "Delta Task", Dependencies: []string{"T-002"}},
	}
	phases := []Phase{
		{ID: 1, Name: "Setup", StartTask: "T-001", EndTask: "T-002"},
		{ID: 2, Name: "Build", StartTask: "T-003", EndTask: "T-004"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude|2024-05-01T00:00:00Z|",
		"T-002|in_progress|codex||",
		"T-003|not_started|||",
		"T-004|blocked|||",
	})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("MixedProject")
	require.NoError(t, err)

	// Header
	assert.Contains(t, out, "# Progress -- MixedProject")
	assert.Contains(t, out, "Auto-generated by Raven")

	// Overall: 1 of 4 completed = 25%
	assert.Contains(t, out, "1/4 tasks completed (25%)")

	// Phase headings present
	assert.Contains(t, out, "## Phase 1: Setup")
	assert.Contains(t, out, "## Phase 2: Build")

	// All task IDs and their statuses present
	assert.Contains(t, out, "T-001")
	assert.Contains(t, out, "completed")
	assert.Contains(t, out, "T-002")
	assert.Contains(t, out, "in_progress")
	assert.Contains(t, out, "T-003")
	assert.Contains(t, out, "not_started")
	assert.Contains(t, out, "T-004")
	assert.Contains(t, out, "blocked")

	// Markdown table header row appears once per phase
	assert.Equal(t, 2, strings.Count(out, "| Task | Title | Status | Agent | Updated |"),
		"each phase must have exactly one table header row")

	// Phases appear in document order
	posPhase1 := strings.Index(out, "## Phase 1: Setup")
	posPhase2 := strings.Index(out, "## Phase 2: Build")
	assert.Greater(t, posPhase2, posPhase1, "Phase 2 must appear after Phase 1")

	// Agent visible for completed and in_progress; not for blocked/not_started
	assert.Contains(t, out, "claude",  "completed task agent must appear")
	assert.Contains(t, out, "codex", "in_progress task agent must appear")
}

// ---- Generate: all tasks completed 100% (acceptance criterion) ---------------

// TestGenerate_AllCompleted_100Percent is the acceptance-criteria test for
// "Generate with all tasks completed: 100% overall."
func TestGenerate_AllCompleted_100Percent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Task One", Dependencies: []string{}},
		{ID: "T-002", Title: "Task Two", Dependencies: []string{}},
		{ID: "T-003", Title: "Task Three", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase A", StartTask: "T-001", EndTask: "T-002"},
		{ID: 2, Name: "Phase B", StartTask: "T-003", EndTask: "T-003"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
		"T-002|completed|codex||",
		"T-003|completed|claude||",
	})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("FullProject")
	require.NoError(t, err)

	assert.Contains(t, out, "3/3 tasks completed (100%)")
	// Both phase progress bars must be all filled (16 full-block chars).
	assert.Equal(t, 2, strings.Count(out, strings.Repeat("█", 16)),
		"both phase bars must be 100%% filled")
}

// ---- Generate: no tasks, empty phases (acceptance criterion) -----------------

// TestGenerate_EmptyPhases_NoTaskRows is the acceptance-criteria test for
// "Generate with no tasks: empty phases sections."
// With no specs, phase task IDs exist in the numeric range but no rows are
// emitted (tasks without specs are counted in Total but omitted from the table).
func TestGenerate_EmptyPhases_NoTaskRows(t *testing.T) {
	t.Parallel()

	// Phases with ranges but no specs -- all tasks in range are unmanaged.
	// Each phase range covers 2 IDs: Total=2 per phase, 4 overall.
	phases := []Phase{
		{ID: 1, Name: "Empty Phase One", StartTask: "T-001", EndTask: "T-002"},
		{ID: 2, Name: "Empty Phase Two", StartTask: "T-010", EndTask: "T-011"},
	}
	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("EmptyProject")
	require.NoError(t, err)

	assert.Contains(t, out, "## Phase 1: Empty Phase One")
	assert.Contains(t, out, "## Phase 2: Empty Phase Two")
	// Unmanaged tasks (no spec) still contribute to OverallTotal.
	// 2 phases x 2 IDs each = 4 total, 0 completed.
	assert.Contains(t, out, "0/4 tasks completed (0%)")
	// No task rows should appear in the table (tasks without specs are skipped).
	assert.NotContains(t, out, "| T-001 |")
	assert.NotContains(t, out, "| T-010 |")
}

// ---- Generate: tasks missing from state shown as not_started (acceptance) ---

// TestGenerate_TasksMissingFromState_NotStarted is the acceptance-criteria test
// for "Generate with tasks missing from state file: shown as not_started."
func TestGenerate_TasksMissingFromState_NotStarted(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Has State", Dependencies: []string{}},
		{ID: "T-002", Title: "No State Entry", Dependencies: []string{}},
		{ID: "T-003", Title: "Also No State", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-003"},
	}
	// Only T-001 has a state entry; T-002 and T-003 are absent from the file.
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
	})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("MissingStateProject")
	require.NoError(t, err)

	assert.Contains(t, out, "T-002", "T-002 must appear even without a state entry")
	assert.Contains(t, out, "T-003", "T-003 must appear even without a state entry")
	assert.Contains(t, out, "not_started", "tasks missing from state must show not_started")
	assert.Contains(t, out, "1/3 tasks completed (33%)")
}

// ---- buildProgressData: direct struct verification --------------------------

// TestBuildProgressData_GeneratedAtIsRecent verifies GeneratedAt is within a
// short window around the current time and is UTC.
func TestBuildProgressData_GeneratedAtIsRecent(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	before := time.Now().UTC().Add(-2 * time.Second)
	data, err := pg.buildProgressData("TimeTest")
	after := time.Now().UTC().Add(2 * time.Second)
	require.NoError(t, err)

	assert.True(t, data.GeneratedAt.After(before), "GeneratedAt must be after call start")
	assert.True(t, data.GeneratedAt.Before(after), "GeneratedAt must be before call end")
	assert.Equal(t, time.UTC, data.GeneratedAt.Location(), "GeneratedAt must be UTC")
}

// TestBuildProgressData_ProjectNamePropagated verifies ProjectName is set
// exactly as provided to buildProgressData.
func TestBuildProgressData_ProjectNamePropagated(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	data, err := pg.buildProgressData("my-raven-project")
	require.NoError(t, err)

	assert.Equal(t, "my-raven-project", data.ProjectName)
}

// TestBuildProgressData_EmptyPhases_ZeroOverall verifies that with no phases
// all overall counters are zero and the Phases slice is empty.
func TestBuildProgressData_EmptyPhases_ZeroOverall(t *testing.T) {
	t.Parallel()

	sm := emptyStateManager(t)
	pg, err := NewProgressGenerator(nil, sm, []Phase{})
	require.NoError(t, err)

	data, err := pg.buildProgressData("ZeroTest")
	require.NoError(t, err)

	assert.Equal(t, 0, data.OverallTotal)
	assert.Equal(t, 0, data.OverallComplete)
	assert.Equal(t, 0, data.OverallPercent)
	assert.Empty(t, data.Phases)
}

// TestBuildProgressData_OverallPercent_RoundsDown verifies integer floor
// division (1/3*100 = 33, not 34).
func TestBuildProgressData_OverallPercent_RoundsDown(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
		makeSpec("T-003", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-003"},
	}
	sm := writeStateContent(t, []string{"T-001|completed|claude||"})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	data, err := pg.buildProgressData("RoundDown")
	require.NoError(t, err)

	assert.Equal(t, 33, data.OverallPercent, "1/3*100 floor = 33, not 34")
}

// TestBuildProgressData_PhaseProgressBar_CorrectPercent verifies the
// ProgressBar and Percent fields inside PhaseProgressData are set correctly.
func TestBuildProgressData_PhaseProgressBar_CorrectPercent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Half Done", StartTask: "T-001", EndTask: "T-002"},
	}
	sm := writeStateContent(t, []string{"T-001|completed|claude||"})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	data, err := pg.buildProgressData("BarTest")
	require.NoError(t, err)

	require.Len(t, data.Phases, 1)
	pd := data.Phases[0]
	assert.Equal(t, 50, pd.Percent)
	assert.Equal(t, strings.Repeat("█", 8)+strings.Repeat("░", 8), pd.ProgressBar)
}

// TestBuildProgressData_PhaseDataFields verifies all count fields of
// PhaseProgressData for a phase with one task of each status.
func TestBuildProgressData_PhaseDataFields(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil), // completed
		makeSpec("T-002", nil), // in_progress
		makeSpec("T-003", nil), // blocked
		makeSpec("T-004", nil), // skipped
		makeSpec("T-005", nil), // not_started (no state entry)
	}
	phases := []Phase{
		{ID: 3, Name: "Mixed Status Phase", StartTask: "T-001", EndTask: "T-005"},
	}
	sm := writeStateContent(t, []string{
		"T-001|completed|claude||",
		"T-002|in_progress|codex||",
		"T-003|blocked|||",
		"T-004|skipped|||",
	})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	data, err := pg.buildProgressData("FieldTest")
	require.NoError(t, err)
	require.Len(t, data.Phases, 1)

	pd := data.Phases[0]
	assert.Equal(t, 3, pd.ID)
	assert.Equal(t, "Mixed Status Phase", pd.Name)
	assert.Equal(t, 5, pd.Total)
	assert.Equal(t, 1, pd.Completed)
	assert.Equal(t, 1, pd.InProgress)
	assert.Equal(t, 1, pd.Blocked)
	assert.Equal(t, 1, pd.Skipped)
	assert.Equal(t, 1, pd.NotStarted)
	assert.Equal(t, 20, pd.Percent, "1 of 5 completed = 20%%")
	assert.Len(t, pd.Tasks, 5, "all 5 specs must produce task rows")
}

// TestBuildProgressData_TaskDataFields verifies all fields of TaskProgressData
// for a completed task with a known timestamp.
func TestBuildProgressData_TaskDataFields(t *testing.T) {
	t.Parallel()

	spec := &ParsedTaskSpec{
		ID:           "T-007",
		Title:        "Verify Fields",
		Dependencies: []string{},
	}
	phases := []Phase{{ID: 1, Name: "P1", StartTask: "T-007", EndTask: "T-007"}}

	ts := time.Date(2025, 12, 25, 0, 0, 0, 0, time.UTC)
	line := fmt.Sprintf("T-007|completed|gemini|%s|\n", ts.Format(time.RFC3339))
	dir := t.TempDir()
	path := filepath.Join(dir, "task-state.conf")
	require.NoError(t, os.WriteFile(path, []byte(line), 0644))
	sm := NewStateManager(path)

	pg, err := NewProgressGenerator([]*ParsedTaskSpec{spec}, sm, phases)
	require.NoError(t, err)

	data, err := pg.buildProgressData("FieldTaskTest")
	require.NoError(t, err)

	require.Len(t, data.Phases, 1)
	require.Len(t, data.Phases[0].Tasks, 1)

	td := data.Phases[0].Tasks[0]
	assert.Equal(t, "T-007", td.ID)
	assert.Equal(t, "Verify Fields", td.Title)
	assert.Equal(t, "completed", td.Status)
	assert.Equal(t, "gemini", td.Agent)
	assert.Equal(t, "2025-12-25", td.Timestamp)
}

// TestBuildProgressData_TaskRow_TitlePipeEscapedInData verifies pipe chars in
// task titles are escaped inside the TaskProgressData struct itself (not just in
// template rendering).
func TestBuildProgressData_TaskRow_TitlePipeEscapedInData(t *testing.T) {
	t.Parallel()

	spec := &ParsedTaskSpec{
		ID:           "T-001",
		Title:        "Setup | Config | Deploy",
		Dependencies: []string{},
	}
	phases := []Phase{{ID: 1, Name: "P1", StartTask: "T-001", EndTask: "T-001"}}
	sm := emptyStateManager(t)

	pg, err := NewProgressGenerator([]*ParsedTaskSpec{spec}, sm, phases)
	require.NoError(t, err)

	data, err := pg.buildProgressData("PipeTest")
	require.NoError(t, err)

	require.Len(t, data.Phases, 1)
	require.Len(t, data.Phases[0].Tasks, 1)

	td := data.Phases[0].Tasks[0]
	assert.Equal(t, `Setup \| Config \| Deploy`, td.Title)
}

// ---- Agent visibility per status (acceptance criterion) ----------------------

// TestGenerate_TaskRow_SkippedShowsAgent verifies that skipped tasks retain
// their agent value (unlike blocked/not_started which clear it).
func TestGenerate_TaskRow_SkippedShowsAgent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Skipped Task", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{"T-001|skipped|gemini||"})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("SkippedTest")
	require.NoError(t, err)

	assert.Contains(t, out, "skipped")
	assert.Contains(t, out, "gemini", "skipped task must show the agent column value")
}

// TestGenerate_TaskRow_BlockedClearsAgent verifies that even when the state
// file records an agent for a blocked task, the output shows no agent.
func TestGenerate_TaskRow_BlockedClearsAgent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Blocked Task", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{"T-001|blocked|claude||"})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("BlockedTest")
	require.NoError(t, err)

	assert.Contains(t, out, "blocked")
	assert.NotContains(t, out, "claude",
		"blocked task must NOT show the agent even if state file has one")
}

// TestGenerate_TaskRow_NotStartedClearsAgent verifies that even a not_started
// task with a (nonsensically) filled-in agent is rendered without one.
func TestGenerate_TaskRow_NotStartedClearsAgent(t *testing.T) {
	t.Parallel()

	specs := []*ParsedTaskSpec{
		{ID: "T-001", Title: "Fresh Task", Dependencies: []string{}},
	}
	phases := []Phase{
		{ID: 1, Name: "Phase One", StartTask: "T-001", EndTask: "T-001"},
	}
	sm := writeStateContent(t, []string{"T-001|not_started|some-agent||"})

	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("AgentClearTest")
	require.NoError(t, err)

	assert.Contains(t, out, "not_started")
	assert.NotContains(t, out, "some-agent",
		"not_started task must NOT show agent column value")
}

// ---- All status combinations rendered without error -------------------------

// TestGenerate_AllStatusCombinations verifies the template renders without error
// for every valid TaskStatus, satisfying the acceptance criterion
// "Template renders without error for all combinations."
func TestGenerate_AllStatusCombinations(t *testing.T) {
	t.Parallel()

	type statusCase struct {
		status TaskStatus
		agent  string
	}
	cases := []statusCase{
		{StatusNotStarted, ""},
		{StatusInProgress, "claude"},
		{StatusCompleted, "codex"},
		{StatusBlocked, "gemini"},
		{StatusSkipped, "claude"},
	}

	for _, sc := range cases {
		sc := sc
		t.Run(string(sc.status), func(t *testing.T) {
			t.Parallel()

			spec := &ParsedTaskSpec{ID: "T-001", Title: "Status Test Task", Dependencies: []string{}}
			phases := []Phase{{ID: 1, Name: "P1", StartTask: "T-001", EndTask: "T-001"}}

			var sm *StateManager
			if sc.status == StatusNotStarted {
				sm = emptyStateManager(t)
			} else {
				sm = writeStateContent(t, []string{
					fmt.Sprintf("T-001|%s|%s||", string(sc.status), sc.agent),
				})
			}

			pg, err := NewProgressGenerator([]*ParsedTaskSpec{spec}, sm, phases)
			require.NoError(t, err)

			out, err := pg.Generate("StatusCombo")
			require.NoError(t, err, "template must render without error for status %q", sc.status)

			assert.Contains(t, out, string(sc.status))
			assert.Contains(t, out, "T-001")
		})
	}
}

// ---- Concurrent Generate (race detector) ------------------------------------

// TestGenerate_ConcurrentCalls verifies that multiple goroutines can call
// Generate simultaneously without data races.
// Run with: go test -race ./internal/task/...
func TestGenerate_ConcurrentCalls(t *testing.T) {
	specs := []*ParsedTaskSpec{
		makeSpec("T-001", nil),
		makeSpec("T-002", nil),
	}
	phases := []Phase{
		{ID: 1, Name: "Concurrent Phase", StartTask: "T-001", EndTask: "T-002"},
	}
	sm := writeStateContent(t, []string{"T-001|completed|claude||"})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	const goroutines = 10
	var wg sync.WaitGroup
	errs := make([]error, goroutines)

	for i := 0; i < goroutines; i++ {
		i := i
		wg.Add(1)
		go func() {
			defer wg.Done()
			_, errs[i] = pg.Generate("ConcurrentProject")
		}()
	}
	wg.Wait()

	for i, gerr := range errs {
		assert.NoError(t, gerr, "goroutine %d should not error", i)
	}
}

// ---- Large phase (correctness at scale) -------------------------------------

// TestGenerate_LargePhase verifies Generate handles 50 tasks without errors
// and produces correct aggregate counts.
func TestGenerate_LargePhase(t *testing.T) {
	t.Parallel()

	const n = 50
	specs := make([]*ParsedTaskSpec, n)
	stateLines := make([]string, 0, n)
	for i := 0; i < n; i++ {
		id := fmt.Sprintf("T-%03d", i+1)
		specs[i] = makeSpec(id, nil)
		if i%2 == 0 {
			stateLines = append(stateLines, id+"|completed|claude||")
		}
	}

	phases := []Phase{
		{ID: 1, Name: "Large Phase", StartTask: "T-001", EndTask: fmt.Sprintf("T-%03d", n)},
	}
	sm := writeStateContent(t, stateLines)
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(t, err)

	out, err := pg.Generate("LargeProject")
	require.NoError(t, err)

	// 25 completed out of 50 = 50%
	assert.Contains(t, out, "25/50 tasks completed (50%)")
	// Spot-check a few task IDs
	assert.Contains(t, out, "T-001")
	assert.Contains(t, out, "T-025")
	assert.Contains(t, out, "T-050")
}

// ---- Benchmark tests --------------------------------------------------------

// BenchmarkGenerate measures Generate throughput for a 3-phase, 15-task setup.
func BenchmarkGenerate(b *testing.B) {
	const tasksPerPhase = 5
	const phaseCount = 3
	const total = tasksPerPhase * phaseCount

	specs := make([]*ParsedTaskSpec, total)
	stateLines := make([]string, 0, total)
	phases := make([]Phase, phaseCount)

	for p := 0; p < phaseCount; p++ {
		start := p*tasksPerPhase + 1
		end := start + tasksPerPhase - 1
		phases[p] = Phase{
			ID:        p + 1,
			Name:      fmt.Sprintf("Phase %d", p+1),
			StartTask: fmt.Sprintf("T-%03d", start),
			EndTask:   fmt.Sprintf("T-%03d", end),
		}
		for i := start; i <= end; i++ {
			id := fmt.Sprintf("T-%03d", i)
			specs[i-1] = makeSpec(id, nil)
			stateLines = append(stateLines, id+"|completed|claude||")
		}
	}

	sm := writeStateContentTB(b, stateLines)
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(b, err)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if _, err := pg.Generate("BenchProject"); err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkTextProgressBar measures textProgressBar throughput.
func BenchmarkTextProgressBar(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = textProgressBar(i%101, 16)
	}
}

// BenchmarkWriteFile measures WriteFile throughput including the atomic rename.
func BenchmarkWriteFile(b *testing.B) {
	specs := []*ParsedTaskSpec{makeSpec("T-001", nil)}
	phases := []Phase{{ID: 1, Name: "Bench Phase", StartTask: "T-001", EndTask: "T-001"}}
	sm := writeStateContentTB(b, []string{"T-001|completed|claude||"})
	pg, err := NewProgressGenerator(specs, sm, phases)
	require.NoError(b, err)

	dir := b.TempDir()
	path := filepath.Join(dir, "PROGRESS.md")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if err := pg.WriteFile(path, "BenchProject"); err != nil {
			b.Fatal(err)
		}
	}
}

// ---- writeStateContent extension for testing.TB (used by benchmarks above) --
// NOTE: writeStateContent is defined in selector_test.go for *testing.T.
// The version below accepts testing.TB so benchmark functions can reuse it.
// It is intentionally named differently to avoid a duplicate-function conflict.

func writeStateContentTB(tb testing.TB, lines []string) *StateManager {
	tb.Helper()
	content := strings.Join(lines, "\n")
	if len(lines) > 0 {
		content += "\n"
	}
	dir := tb.TempDir()
	path := filepath.Join(dir, "task-state.conf")
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		tb.Fatalf("writeStateContentTB: %v", err)
	}
	return NewStateManager(path)
}
