package task

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// progressTemplate is the embedded markdown template for PROGRESS.md.
const progressTemplate = `# Progress -- {{.ProjectName}}

> Auto-generated by Raven. Last updated: {{.GeneratedAt.Format "2006-01-02 15:04:05 MST"}}

## Overall Progress

**{{.OverallComplete}}/{{.OverallTotal}} tasks completed ({{.OverallPercent}}%)**

{{range .Phases}}
## Phase {{.ID}}: {{.Name}}

{{.ProgressBar}} {{.Percent}}% ({{.Completed}}/{{.Total}})

| Task | Title | Status | Agent | Updated |
|------|-------|--------|-------|---------|
{{range .Tasks}}| {{.ID}} | {{.Title}} | {{.Status}} | {{.Agent}} | {{.Timestamp}} |
{{end}}
{{end}}`

// ProgressData holds all data for rendering the progress template.
type ProgressData struct {
	// ProjectName is the name of the project displayed in the header.
	ProjectName string
	// GeneratedAt is the time the document was generated.
	GeneratedAt time.Time
	// OverallTotal is the count of all tasks across all phases.
	OverallTotal int
	// OverallComplete is the count of completed tasks across all phases.
	OverallComplete int
	// OverallPercent is the overall completion percentage (0-100).
	OverallPercent int
	// Phases contains per-phase progress data in phase ID order.
	Phases []PhaseProgressData
}

// PhaseProgressData holds progress data for a single phase.
type PhaseProgressData struct {
	// ID is the numeric phase identifier.
	ID int
	// Name is the human-readable phase name.
	Name string
	// Total is the number of tasks in the phase.
	Total int
	// Completed is the count of completed tasks.
	Completed int
	// InProgress is the count of in-progress tasks.
	InProgress int
	// Blocked is the count of blocked tasks.
	Blocked int
	// Skipped is the count of skipped tasks.
	Skipped int
	// NotStarted is the count of not-started tasks.
	NotStarted int
	// Percent is the completion percentage (0-100).
	Percent int
	// ProgressBar is a text-based progress bar: "████████░░░░░░░░"
	ProgressBar string
	// Tasks contains the per-task progress rows for this phase.
	Tasks []TaskProgressData
}

// TaskProgressData holds progress data for a single task row.
type TaskProgressData struct {
	// ID is the task identifier (e.g. "T-016").
	ID string
	// Title is the human-readable task title (pipe chars escaped).
	Title string
	// Status is the current task status string.
	Status string
	// Agent is the agent that last acted on the task (may be empty).
	Agent string
	// Timestamp is the formatted update timestamp (may be empty).
	Timestamp string
}

// ProgressGenerator creates PROGRESS.md content from task state and phase data.
type ProgressGenerator struct {
	specs   []*ParsedTaskSpec
	specMap map[string]*ParsedTaskSpec
	state   *StateManager
	phases  []Phase
	tmpl    *template.Template
}

// NewProgressGenerator creates a ProgressGenerator from task system components.
// specs is the complete list of parsed task specs; state is used to read task
// status, agent, and timestamps; phases determines the phase structure and
// ordering.
func NewProgressGenerator(specs []*ParsedTaskSpec, state *StateManager, phases []Phase) (*ProgressGenerator, error) {
	tmpl, err := template.New("progress").Parse(progressTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing progress template: %w", err)
	}

	specMap := make(map[string]*ParsedTaskSpec, len(specs))
	for _, s := range specs {
		specMap[s.ID] = s
	}

	return &ProgressGenerator{
		specs:   specs,
		specMap: specMap,
		state:   state,
		phases:  phases,
		tmpl:    tmpl,
	}, nil
}

// Generate produces the PROGRESS.md content as a string.
// projectName is embedded in the document header.
func (pg *ProgressGenerator) Generate(projectName string) (string, error) {
	var buf bytes.Buffer
	if err := pg.WriteTo(&buf, projectName); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// WriteTo writes the generated PROGRESS.md content to w.
func (pg *ProgressGenerator) WriteTo(w io.Writer, projectName string) error {
	data, err := pg.buildProgressData(projectName)
	if err != nil {
		return fmt.Errorf("building progress data: %w", err)
	}

	if err := pg.tmpl.Execute(w, data); err != nil {
		return fmt.Errorf("rendering progress template: %w", err)
	}
	return nil
}

// WriteFile writes the generated PROGRESS.md to path atomically using
// a write-to-temp-then-rename pattern to prevent corruption.
// Parent directories are created as needed.
func (pg *ProgressGenerator) WriteFile(path string, projectName string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("creating directory %q: %w", dir, err)
	}

	content, err := pg.Generate(projectName)
	if err != nil {
		return err
	}

	tmpPath := path + ".tmp"
	if err := os.WriteFile(tmpPath, []byte(content), 0o600); err != nil {
		return fmt.Errorf("writing temp progress file %q: %w", tmpPath, err)
	}

	if err := os.Rename(tmpPath, path); err != nil {
		os.Remove(tmpPath) //nolint:errcheck
		return fmt.Errorf("renaming temp progress file to %q: %w", path, err)
	}

	return nil
}

// buildProgressData assembles all ProgressData from state and spec information.
func (pg *ProgressGenerator) buildProgressData(projectName string) (ProgressData, error) {
	stateMap, err := pg.state.LoadMap()
	if err != nil {
		return ProgressData{}, fmt.Errorf("loading task state: %w", err)
	}

	data := ProgressData{
		ProjectName: projectName,
		GeneratedAt: time.Now().UTC(),
	}

	for _, phase := range pg.phases {
		phaseData, err := pg.buildPhaseProgressData(phase, stateMap)
		if err != nil {
			return ProgressData{}, fmt.Errorf("building phase %d progress: %w", phase.ID, err)
		}
		data.Phases = append(data.Phases, phaseData)
		data.OverallTotal += phaseData.Total
		data.OverallComplete += phaseData.Completed
	}

	if data.OverallTotal > 0 {
		data.OverallPercent = data.OverallComplete * 100 / data.OverallTotal
	}

	return data, nil
}

// buildPhaseProgressData builds the per-phase progress data for a single phase.
func (pg *ProgressGenerator) buildPhaseProgressData(phase Phase, stateMap map[string]*TaskState) (PhaseProgressData, error) { //nolint:unparam // error return reserved for future phases
	ids := TasksInPhase(phase)

	phaseData := PhaseProgressData{
		ID:    phase.ID,
		Name:  phase.Name,
		Total: len(ids),
	}

	for _, id := range ids {
		spec, inSpec := pg.specMap[id]
		if !inSpec {
			// Task in range but no spec file: treat as not_started, skip row.
			phaseData.NotStarted++
			continue
		}

		ts := stateMap[id]
		status := StatusNotStarted
		if ts != nil {
			status = ts.Status
		}

		switch status {
		case StatusCompleted:
			phaseData.Completed++
		case StatusInProgress:
			phaseData.InProgress++
		case StatusBlocked:
			phaseData.Blocked++
		case StatusSkipped:
			phaseData.Skipped++
		default:
			phaseData.NotStarted++
		}

		taskData := pg.buildTaskProgressData(spec, ts, status)
		phaseData.Tasks = append(phaseData.Tasks, taskData)
	}

	if phaseData.Total > 0 {
		phaseData.Percent = phaseData.Completed * 100 / phaseData.Total
	}
	phaseData.ProgressBar = textProgressBar(phaseData.Percent, 16)

	return phaseData, nil
}

// buildTaskProgressData constructs a TaskProgressData row for a single task.
// ts may be nil if the task has no state entry (treated as not_started).
func (pg *ProgressGenerator) buildTaskProgressData(spec *ParsedTaskSpec, ts *TaskState, status TaskStatus) TaskProgressData {
	td := TaskProgressData{
		ID:     spec.ID,
		Title:  escapePipeChars(spec.Title),
		Status: string(status),
	}

	if ts != nil {
		td.Agent = ts.Agent
		if !ts.Timestamp.IsZero() {
			td.Timestamp = ts.Timestamp.UTC().Format("2006-01-02")
		}
	}

	// Blocked and not_started tasks show empty agent per acceptance criteria.
	if status == StatusBlocked || status == StatusNotStarted {
		td.Agent = ""
	}

	return td
}

// textProgressBar generates a text-based progress bar of the given width.
// filled characters are "█" and empty characters are "░".
// Example: textProgressBar(60, 16) -> "██████████░░░░░░"
func textProgressBar(percent int, width int) string {
	if percent < 0 {
		percent = 0
	}
	if percent > 100 {
		percent = 100
	}
	filled := percent * width / 100
	empty := width - filled
	return strings.Repeat("█", filled) + strings.Repeat("░", empty)
}

// escapePipeChars replaces literal pipe characters in s with `\|` so that they
// do not break the markdown table column boundaries.
func escapePipeChars(s string) string {
	return strings.ReplaceAll(s, "|", `\|`)
}
