# T-030: Progress File Generation -- PROGRESS.md

## Metadata
| Field | Value |
|-------|-------|
| Priority | Must Have |
| Estimated Effort | Small: 4-6hrs |
| Dependencies | T-004, T-016, T-017, T-018, T-019 |
| Blocked By | T-017, T-019 |
| Blocks | None |

## Goal
Implement the PROGRESS.md file generator that produces a human-readable markdown document summarizing task completion status across all phases. This file is updated after each task completion, providing a persistent, version-controlled progress record that developers and CI can reference without running Raven.

## Background
Per PRD Section 5.3, "Progress tracking: `PROGRESS.md` updated after each task completion." The file path is configured via `project.progress_file` in `raven.toml` (default: `docs/tasks/PROGRESS.md`). The PROGRESS.md file should show:
- Overall completion percentage and count
- Per-phase breakdown with completion bars (text-based)
- Per-task status with timestamps and agent used
- Last updated timestamp

This file complements the `raven status` command (T-020) by providing a static, committable artifact. It is generated from the same data sources: task specs (T-016), task state (T-017), phase config (T-018), and the task selector (T-019).

## Technical Specifications
### Implementation Approach
Create `internal/task/progress.go` containing a `ProgressGenerator` that reads task state and phase information and produces a formatted PROGRESS.md file. Use `text/template` for rendering the markdown output. The generator is called by the implementation loop (T-027) after each task completion and can also be invoked standalone for regeneration.

### Key Components
- **ProgressGenerator**: Reads state and produces PROGRESS.md content
- **ProgressData**: Structured data for template rendering
- **Template**: Embedded markdown template for PROGRESS.md format
- **WriteProgress**: Atomic file write to prevent corruption

### API/Interface Contracts
```go
// internal/task/progress.go
package task

import (
    "io"
    "text/template"
    "time"
)

// ProgressGenerator creates PROGRESS.md from task state and phase data.
type ProgressGenerator struct {
    selector *TaskSelector
    phases   []Phase
}

// NewProgressGenerator creates a generator from task system components.
func NewProgressGenerator(selector *TaskSelector, phases []Phase) *ProgressGenerator

// ProgressData holds all data for rendering the progress template.
type ProgressData struct {
    ProjectName     string
    GeneratedAt     time.Time
    OverallTotal    int
    OverallComplete int
    OverallPercent  int
    Phases          []PhaseProgressData
}

// PhaseProgressData holds progress data for a single phase.
type PhaseProgressData struct {
    ID          int
    Name        string
    Total       int
    Completed   int
    InProgress  int
    Blocked     int
    Skipped     int
    NotStarted  int
    Percent     int
    ProgressBar string // Text-based progress bar: "████████░░░░░░░░"
    Tasks       []TaskProgressData
}

// TaskProgressData holds progress data for a single task.
type TaskProgressData struct {
    ID        string
    Title     string
    Status    string
    Agent     string
    Timestamp string // Formatted timestamp
}

// Generate produces the PROGRESS.md content as a string.
func (pg *ProgressGenerator) Generate(projectName string) (string, error)

// WriteTo writes the generated PROGRESS.md to the given writer.
func (pg *ProgressGenerator) WriteTo(w io.Writer, projectName string) error

// WriteFile writes the PROGRESS.md to the given file path atomically.
// Uses write-to-temp-then-rename pattern to prevent corruption.
func (pg *ProgressGenerator) WriteFile(path string, projectName string) error

// textProgressBar generates a text-based progress bar.
// width is the total character width of the bar.
// Example: textProgressBar(60, 16) -> "██████████░░░░░░"
func textProgressBar(percent int, width int) string
```

```go
// Embedded template for PROGRESS.md

const progressTemplate = `# Progress -- {{.ProjectName}}

> Auto-generated by Raven. Last updated: {{.GeneratedAt.Format "2006-01-02 15:04:05 MST"}}

## Overall Progress

**{{.OverallComplete}}/{{.OverallTotal}} tasks completed ({{.OverallPercent}}%)**

{{range .Phases}}
## Phase {{.ID}}: {{.Name}}

{{.ProgressBar}} {{.Percent}}% ({{.Completed}}/{{.Total}})

| Task | Title | Status | Agent | Updated |
|------|-------|--------|-------|---------|
{{range .Tasks}}| {{.ID}} | {{.Title}} | {{.Status}} | {{.Agent}} | {{.Timestamp}} |
{{end}}
{{end}}`
```

### Dependencies & Versions
| Package/Library | Version | Purpose |
|-----------------|---------|---------|
| text/template | stdlib | Markdown template rendering |
| os | stdlib | File writing |
| io | stdlib | Writer interface |
| time | stdlib | Timestamps |
| strings | stdlib | Progress bar construction |
| fmt | stdlib | Percentage formatting |
| internal/task (T-016) | - | ParsedTaskSpec for task titles |
| internal/task (T-017) | - | StateManager for task statuses |
| internal/task (T-018) | - | Phase definitions |
| internal/task (T-019) | - | TaskSelector for progress data |
| stretchr/testify | v1.9+ | Test assertions |

## Acceptance Criteria
- [ ] Generate produces valid markdown with overall progress summary
- [ ] Per-phase sections show completion count, percentage, and progress bar
- [ ] Per-task rows show task ID, title, status, agent, and timestamp
- [ ] Text progress bar renders correctly at various percentages (0%, 50%, 100%)
- [ ] WriteFile uses atomic write (temp file + rename)
- [ ] Output includes "Auto-generated by Raven" header with timestamp
- [ ] Tasks within each phase are ordered by ID
- [ ] Completed tasks show the agent that completed them
- [ ] In-progress tasks show the current agent
- [ ] Blocked and not_started tasks show empty agent column
- [ ] 0% progress phases show empty progress bar
- [ ] 100% progress phases show full progress bar
- [ ] WriteTo works with any io.Writer (for testing)
- [ ] Unit tests achieve 90% coverage

## Testing Requirements
### Unit Tests
- textProgressBar(0, 16) returns all empty characters
- textProgressBar(50, 16) returns half filled
- textProgressBar(100, 16) returns all filled
- textProgressBar(33, 16) returns approximately one-third filled
- Generate with 2 phases, mixed statuses: correct markdown output
- Generate with all tasks completed: 100% overall
- Generate with no tasks: empty phases sections
- Generate with tasks missing from state file: shown as not_started
- WriteFile creates valid file at path
- WriteFile is atomic (temp file exists during write, renamed after)
- WriteTo writes to buffer correctly
- ProgressData computed correctly from task selector
- Template renders without error for all combinations of phase progress

### Integration Tests
- Generate PROGRESS.md using actual testdata tasks and state
- Verify generated markdown renders correctly in a markdown viewer (visual check)

### Edge Cases to Handle
- Task with very long title: truncate in table or let markdown handle wrapping
- Phase with no tasks: show "No tasks in this phase"
- Task state file empty: all tasks shown as not_started
- Task in state file but not in spec files (orphaned state): skip or warn
- Task in spec files but not in state file: shown as not_started
- Unicode characters in task titles or phase names
- Progress file path in non-existent directory: create directory before writing
- Concurrent writes (two loop runners updating simultaneously): atomic write prevents corruption

## Implementation Notes
### Recommended Approach
1. Define ProgressData and related structs first
2. Implement textProgressBar: use `strings.Repeat("█", filled) + strings.Repeat("░", empty)` where `filled = percent * width / 100`
3. Define the progressTemplate constant
4. Generate: build ProgressData from selector.GetAllProgress(), populate task details from specs and state
5. Render using `template.Must(template.New("progress").Parse(progressTemplate))` then `tmpl.Execute(buf, data)`
6. WriteFile: write to `path + ".tmp"`, then `os.Rename(tmpPath, path)`
7. Call this from the loop runner (T-027) after each task state update
8. Also expose as a standalone function for `raven status --update-progress` or manual regeneration

### Potential Pitfalls
- The progress template uses Go template syntax with range blocks -- ensure the template parses correctly before executing
- Pipe characters (`|`) in task titles will break the markdown table -- escape them as `\|`
- Timestamps should use a human-readable format, not RFC3339 (which is verbose in a table)
- The atomic write pattern requires the temp file to be in the same directory as the target (cross-device rename fails on some filesystems)
- Do not hold file locks while generating the progress data (reading state + writing progress should be independent operations)

### Security Considerations
- The progress file is committed to version control -- ensure no sensitive data is included
- Task titles and phase names come from user-created files -- no special sanitization needed for markdown
- Atomic write prevents partial file corruption visible to other processes

## References
- [PRD Section 5.3 - Progress tracking](docs/prd/PRD-Raven.md)
- [Go text/template documentation](https://pkg.go.dev/text/template)
- [Atomic file write pattern in Go](https://www.chronohq.com/blog/cross-platform-file-locking-with-go)
